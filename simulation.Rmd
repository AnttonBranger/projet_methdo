---
title: "Simulation"
author: "Branger Antton"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
rm(list = ls())
```

Chargement des packages
```{r}
library(dplyr)
library(sampling)
```


# Paramètres et fonctions

Définition des paramètres 
```{r}
N <- 20000
nA <- 500
nB <- 1000
B <- 5000
```

Fonction utilitaire 
```{r}
logit <- function(x) log(x / (1 - x))
expit <- function(x) exp(x) / (1 + exp(x))
```

# Génération de la population 

```{r}
set.seed(123)
z1 <- rbinom(N, 1, 0.5)
z2 <- runif(N, 0, 2)
z3 <- rexp(N, 1)
z4 <- rchisq(N, 4)

x1 <- z1
x2 <- z2 + 0.3 * x1
x3 <- z3 + 0.2 * (x1 + x2)
x4 <- z4 + 0.1 * (x1 + x2 + x3)

epsilon <- rnorm(N, 0, 1)
y <- 2 + x1 + x2 + x3 + x4 + (1.0 * epsilon) 
true_mu_y <- mean(y) 
```

# Mécanisme de sélection 

Trouver theta0 pour que la somme des probabilités soit égale à nA
```{r}
find_theta0 <- function(t0) {
  sum(expit(t0 + 0.1*x1 + 0.2*x2 + 0.1*x3 + 0.2*x4)) - nA
}
```

```{r}
theta0 <- uniroot(find_theta0, c(-10, 10))$root
pi_A_true <- expit(theta0 + 0.1*x1 + 0.2*x2 + 0.1*x3 + 0.2*x4)
```

# Echantillon de référence 

```{r}
z_PPS <- 2 + x3 # Variable de taille pour le propensity score 
pi_B <- inclusionprobabilities(z_PPS, nB)
dB <- 1/pi_B
```

# Boucle de simulation

```{r}
results <- replicate(B, {
  
  # A. Tirage des échantillons
  # S_A : Poisson sampling 
  R_A <- rbinom(N, 1, pi_A_true)
  S_A_idx <- which(R_A == 1)
  data_A <- data.frame(y = y[S_A_idx], x1 = x1[S_A_idx], x2 = x2[S_A_idx], 
                       x3 = x3[S_A_idx], x4 = x4[S_A_idx])
  
  # S_B : PPS systématique 
  S_B_idx <- which(UPsystematic(pi_B) == 1)
  data_B <- data.frame(x1 = x1[S_B_idx], x2 = x2[S_B_idx], 
                       x3 = x3[S_B_idx], x4 = x4[S_B_idx], d = dB[S_B_idx])
  
  # B. Estimation des scores de propension (Pseudo-ML) 
  # On résout l'équation du score pour obtenir hat_theta
  pseudo_log_lik <- function(theta) {
    xb_A <- as.matrix(cbind(1, data_A[,2:5])) %*% theta
    xb_B <- as.matrix(cbind(1, data_B[,1:4])) %*% theta
    term1 <- sum(xb_A)
    term2 <- sum(data_B$d * log(1 + exp(xb_B)))
    return(term1 - term2)
  }
  
  # Optimisation pour trouver hat_theta
  res_theta <- optim(rep(0, 5), pseudo_log_lik, control = list(fnscale = -1), method = "BFGS")
  hat_theta <- res_theta$par
  
  # Scores estimés pour S_A
  pi_A_est <- expit(as.matrix(cbind(1, data_A[,2:5])) %*% hat_theta)
  
  # C. Modèle de régression (Outcome model) 
  mod_reg <- lm(y ~ x1 + x2 + x3 + x4, data = data_A)
  hat_beta <- coef(mod_reg)
  
  # Prédictions sur S_B
  y_hat_B <- as.matrix(cbind(1, data_B[,1:4])) %*% hat_beta
  
  # D. Calcul des estimateurs 
  # 1. IPW2
  mu_IPW2 <- sum(data_A$y / pi_A_est) / sum(1 / pi_A_est)
  
  # 2. REG (Mass imputation)
  mu_REG <- sum(data_B$d * y_hat_B) / sum(data_B$d)
  
  # 3. DR2 (Doubly Robust)
  term_A <- sum((data_A$y - predict(mod_reg, data_A)) / pi_A_est) / sum(1 / pi_A_est)
  term_B <- sum(data_B$d * y_hat_B) / sum(data_B$d)
  mu_DR2 <- term_A + term_B
  
  return(c(IPW2 = mu_IPW2, REG = mu_REG, DR2 = mu_DR2))
})
```

# Synthèse des résultats

```{r}
final_results <- data.frame(
  True_Mean = true_mu_y,
  Mean_Est = rowMeans(results),
  RB_pct = (rowMeans(results) - true_mu_y) / true_mu_y * 100,
  MSE = rowMeans((results - true_mu_y)^2)
)

print(final_results)
```

